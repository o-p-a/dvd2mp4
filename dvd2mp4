#! /usr/bin/ruby -E:UTF-8
# -*- mode:Ruby; tab-width:4; coding:UTF-8; -*-
# vi:set ft=ruby ts=4 fenc=UTF-8 :
#----------------------------------------------------------------
# DVD IFO VOBをmp4に変換する
#
# 2020/06/14 opa
#----------------------------------------------------------------
ProgName = "dvd2mp4"
Version = "1.01"
#=====dpk===== Copyright2020
Copyright = "Copyright (c) 2020 by opa"
#=====dpk=====
FFMPEG_CMD = "ffmpeg"
FFPROBE_CMD = "ffprobe"
LSDVD_CMD = "lsdvd"

LANGTABLE = {
	"ja" => "jpn",
	"en" => "eng",
	"fr" => "fra",
	"xx" => nil,
}

FF_ANALYZEDURATION = "600M" # 10min
FF_PROBESIZE = "450M" # 450MB

require 'optparse'
require 'open3'
require 'json'
require 'tempfile'
require 'shellwords'
require 'pp'

def var_init
	$PROGRAM_NAME = ProgName
	$metadata = {}
	$rcode = 0
end

def sec2hhmmss(sec, full:false)
	r = ""
	d, m = sec.divmod(1) # 秒以下
	r = sprintf(".%03d", (m * 1000).round)  if m != 0 || full
	d, m = d.divmod(60) # 秒
	r = sprintf("%02d", m) + r
	if d > 0 || full
		d, m = d.divmod(60) # 分
		r = sprintf("%02d:", m) + r
	end
	if d > 0 || full
		d, m = d.divmod(60) # 時
		r = sprintf("%02d:", m) + r
	end
	return r
end

def pos2sec(pos, fr=nil) # Rational(30000,1001)
	case pos
	when /^(\d+)f$/
		return $1.to_f / fr
	when /^(\d+):(\d+):(\d+(?:\.\d*)?)$/
		return $1.to_i * 3600 + $2.to_i * 60 + $3.to_f
	when /^(\d+):(\d+(?:\.\d*)?)$/
		return $1.to_i * 60 + $2.to_f
	when /^(\d+(?:\.\d*)?s?)$/
		return $1.to_f
	else
		fail "位置の指定が不正です: #{pos}"
	end
end

def vts_num_to_i(vts_num)
	if vts_num =~ /^VTS_(\d+)$/i
		i = $1.to_i
	else
		fail "'VTS_n'の形式で指定してください"
	end
	return i
end

def guess_lang(s)
	case s
	when /(英語|English)/i
		return "eng"
	when /(日本語|Japanese)/i
		return "jpn"
	end

	return nil
end

def get_vobfiles(vts_num)
	if vts_num >= 1
		vobfiles = Dir.glob(sprintf("VTS_%02d_*.VOB", vts_num), File::FNM_CASEFOLD).sort
		vobfiles.shift  if vobfiles.size >= 2 && vobfiles.first =~ /^VTS_\d+_0\.VOB/i
		fail "入力VOBファイルがひとつもありません"  if vobfiles.empty?
		ifofiles = Dir.glob(sprintf("VTS_%02d_*.IFO", vts_num), File::FNM_CASEFOLD).sort
	elsif vts_num == 0
		vobfiles = Dir.glob("VIDEO_TS.VOB", File::FNM_CASEFOLD).sort
		fail "VIDEO_TS.VOBがありません"  if vobfiles.empty?
		ifofiles = Dir.glob("VIDEO_TS.IFO", File::FNM_CASEFOLD).sort
	end
	return [vobfiles, ifofiles]
end

def probe_disc_data_raw
	if !File.exist?("VIDEO_TS.IFO")
		fail "DVDのインデックスファイルが存在しません"
	end

	cmd = [LSDVD_CMD]
	cmd += ["-x"]
	cmd += ["-Or", "."]
	r = Open3.capture3(*cmd)

	if r[0].empty?
		printf("%s\n", r[1])
		fail "lsdvdの実行に失敗しました"
	end

	return eval(r[0])
end

def probe_disc_data
	pd = probe_disc_data_raw

	pd[:track].each.with_index(1) do |title, ix|
		fail "lsdvdのタイトル情報に飛び番があります"  if title[:ix] != ix
		# TODO : アングル情報のチェック
		title[:audio].each.with_index(1) do |audio, ix|
			fail "lsdvdのオーディオ情報に飛び番があります"  if audio[:ix] != ix
		end
		title[:chapter].each.with_index(1) do |chapter, ix|
			fail "lsdvdのチャプター情報に飛び番があります"  if chapter[:ix] != ix
		end
		title[:cell].each.with_index(1) do |cell, ix|
			fail "lsdvdのセル情報に飛び番があります"  if cell[:ix] != ix
		end
		title[:subp].each.with_index(1) do |subp, ix|
			fail "lsdvdの字幕情報に飛び番があります"  if subp[:ix] != ix
		end
	end

	vts_wk = {}
	pd[:track].each do |title|
		vts_wk[title[:vts]] ||= []
		vts_wk[title[:vts]] << title
	end
	vts = []
	vts_wk.each do |v, t|
		vts << {vts:v, titles:t}
	end
	vts.sort_by! { |v| v[:vts] }
	vts.each.with_index(1) do |vts, ix|
		fail "使われているVTS番号に飛び番があります"  if vts[:vts] != ix
	end
	pd[:vts] = vts

	if $adjust_fps
		adjust_fps_factor = Rational(30000,1000) / Rational(30000,1001)
		pd[:track].each do |title|
			title[:length] *= adjust_fps_factor
			title[:chapter].each do |chapter|
				chapter[:length] *= adjust_fps_factor
			end
			title[:cell].each do |cell|
				cell[:length] *= adjust_fps_factor
			end
		end
	end

	return pd
end

def probe_vts_data_raw(vts_num)
	vobfiles, ifofiles = get_vobfiles(vts_num)

	cmd1 = ["cat"]
	cmd1 += vobfiles

	cmd2 = [FFPROBE_CMD]
	cmd2 += ["-hide_banner"]
	cmd2 += ["-loglevel", "warning"]
	cmd2 += ["-analyzeduration", FF_ANALYZEDURATION]
	cmd2 += ["-probesize", FF_PROBESIZE]
	cmd2 += ["-print_format", "json"]
	cmd2 += ["-show_format"]
	cmd2 += ["-show_streams"]
	cmd2 += ["-i", "-"]
	return JSON.parse(Open3.pipeline_r(cmd1, cmd2)[0].read, symbolize_names:true)
end

def probe_vts_data(vts_num)
	disc = probe_disc_data
	if vts_num >= 1
		if !disc[:vts][vts_num - 1]
			fail sprintf("VTS_%02dの情報はありません", vts_num)
		end
		titles = disc[:vts][vts_num - 1][:titles]
	else
		titles = []
	end

	chapters = []
	titles.each do |title|
		title[:chapter].each do |chapter|
			cell = title[:cell][chapter[:startcell]-1]
			if !chapters.find { |c|
				c[:length] == chapter[:length] &&
				c[:first_sector] == cell[:first_sector] &&
				c[:last_sector] == cell[:last_sector]
			}
				chapters << {
					ix: nil,
					title: title[:ix],
					title_ix: chapter[:ix],
					vts_ttn: title[:ttn],
					start: nil,
					end: nil,
					length: chapter[:length],
					first_sector: cell[:first_sector],
					last_sector: cell[:last_sector],
				}
			end
		end
	end
	chapters.sort_by! { |c| c[:first_sector] }
	ctmap = {0 => 0.0}
	chapters.each.with_index(1) do |chapter, ix|
		chapter[:ix] = ix
		if !ctmap[chapter[:first_sector]]
			fail "チャプター情報が不連続のため、開始時刻を確定できません"
		end
		chapter[:start] = ctmap[chapter[:first_sector]].round(6)
		ctmap[chapter[:last_sector] + 1] = chapter[:start] + chapter[:length]
		chapter[:end] = ctmap[chapter[:last_sector] + 1].round(6)
	end

	vobfiles, ifofiles = get_vobfiles(vts_num)

	cmd1 = ["cat"]
	cmd1 += vobfiles

	cmd2 = [FFPROBE_CMD]
	cmd2 += ["-hide_banner"]
	cmd2 += ["-loglevel", "error"]
	cmd2 += ["-analyzeduration", FF_ANALYZEDURATION]
	cmd2 += ["-probesize", FF_PROBESIZE]
	cmd2 += ["-print_format", "json"]
	cmd2 += ["-show_format"]
	cmd2 += ["-show_streams"]
	cmd2 += ["-i", "-"]
	ffprobe = JSON.parse(Open3.pipeline_r(cmd1, cmd2)[0].read, symbolize_names:true)

	streams = ffprobe[:streams]
	streams_v = []
	streams_a = []
	streams_s = []
	streams.each.with_index(1) do |stream, ix|
		stream[:ffid] = "0:#{stream[:index]}"
		stream[:ix] = ix
		fail "ffprobeでのストリーム番号に飛び番があります"  if stream[:index] != ix-1

		case stream[:codec_type]
		when "video"
			streams_v << stream
		when "audio"
			streams_a << stream
			streamid = stream[:id].to_i(0)
			lsdvd = nil
			titles.each do |title|
				title[:audio].each do |audio|
					if audio[:streamid].to_i(0) == streamid
						lsdvd = audio
						break
					end
				end
				break  if lsdvd
			end
			if lsdvd
				stream[:langcode] = lsdvd[:langcode]
				stream[:language] = lsdvd[:language]
				stream[:content] = lsdvd[:content]
				stream[:lang] = LANGTABLE[stream[:langcode]]
				fail sprintf("言語コードが変換できません: %s", stream[:langcode])  if !LANGTABLE.include?(stream[:langcode])
			end
		when "subtitle"
			streams_s << stream
			streamid = stream[:id].to_i(0)
			lsdvd = nil
			titles.each do |title|
				title[:subp].each do |subp|
					if subp[:streamid].to_i(0) == streamid
						lsdvd = subp
						break
					end
				end
				break  if lsdvd
			end
			if lsdvd
				stream[:langcode] = lsdvd[:langcode]
				stream[:language] = lsdvd[:language]
				stream[:content] = lsdvd[:content]
				stream[:lang] = LANGTABLE[stream[:langcode]]
				fail sprintf("言語コードが変換できません: %s", stream[:langcode])  if !LANGTABLE.include?(stream[:langcode])
			end
		when "data"
			# NOP
		else
			fail "不明なcodec_typeです: #{stream[:codec_type]}"
		end
	end

	return {
		disc: disc,
		vts_num: vts_num,
		titles: titles,
		chapters: chapters,
		vobfiles: vobfiles,
		ifofiles: ifofiles,
		format: ffprobe[:format],
		streams: streams,
		streams_v: streams_v,
		streams_a: streams_a,
		streams_s: streams_s,
	}
end

def measure_vob_duration(vts_num)
	vobfiles, ifofiles = get_vobfiles(vts_num)
	wfile = Tempfile.new(["vtsmeasure", ".wav"])

	vobtimes = []
	vobfiles.each do |vobfile|
		cmd = [FFPROBE_CMD]
		cmd += ["-hide_banner"]
		cmd += ["-loglevel", "warning"]
		cmd += ["-print_format", "json"]
		cmd += ["-show_format"]
		cmd += ["-i", vobfile]
		r = Open3.capture3(*cmd)
		ffprobe = JSON.parse(r[0], symbolize_names:true)
		vobtimes << {
			filename: vobfile,
			start: ffprobe[:format][:start_time].to_f,
			duration: ffprobe[:format][:duration].to_f,
			end: ffprobe[:format][:start_time].to_f + ffprobe[:format][:duration].to_f,
		}
	end

	return vobtimes.sum { |v| v[:duration] }
end

def measure_strict_duration(vts_num)
	printf("Measuring strict VTS duration...\n")

	vobfiles, ifofiles = get_vobfiles(vts_num)
	wfile = Tempfile.new(["vtsmeasure", ".wav"])

	cmd1 = ["cat"]
	cmd1 += vobfiles

	cmd2 = [FFMPEG_CMD]
	cmd2 += ["-hide_banner"]
	cmd2 += ["-loglevel", "error"]
	cmd2 += ["-y"]
	cmd2 += ["-i", "-"]
	cmd2 += ["-f", "wav"]
	cmd2 += ["-ac", "1"] # モノラル
	cmd2 += ["-codec:a", "pcm_u8"]
	cmd2 += [wfile.path]
	Open3.pipeline(cmd1, cmd2)

	cmd3 = [FFPROBE_CMD]
	cmd3 += ["-hide_banner"]
	cmd3 += ["-loglevel", "warning"]
	cmd3 += ["-print_format", "json"]
	cmd3 += ["-show_format"]
	cmd3 += ["-i", wfile.path]
	ffprobe = JSON.parse(Open3.capture3(*cmd3)[0], symbolize_names:true)

	return ffprobe[:format][:duration].to_f
end

def probe_disc
	pd = probe_disc_data

	printf("disc title : %s\n", pd[:title])  if pd[:title] != "unknown"
	printf("vmg_id : %s\n", pd[:vmg_id])  if pd[:vmg_id] != "DVDVIDEO-VMG"
	printf("provider id : %s\n", pd[:provider_id])  if pd[:provider_id] != ""

	pd[:vts].each do |vts|
		printf("VTS_%02d :", vts[:vts])
		vts[:titles].each_with_index do |title, i|
			if i == 0
				printf(" %dx%d(%s) %0.2ffps", title[:width], title[:height], title[:aspect], title[:fps])
			else
				print("                               ")
			end
			printf(" Title %d %s(%0.1fs)", title[:ix], sec2hhmmss(title[:length], full:true), title[:length])
			aux = ""
			aux += sprintf(" angle:%d", title[:angles])  if title[:angles] != 1
			aux += sprintf(" audio:%d", title[:audio].size)  if title[:audio].size != 1
			aux += sprintf(" subt:%d", title[:subp].size)  if title[:subp].size != 0
			aux += sprintf(" chpt:%d", title[:chapter].size)  if title[:chapter].size != 1
			aux += sprintf(" longest")  if title[:ix] == pd[:longest_track]
			print(" /" + aux)  if !aux.empty?
			print("\n")
		end
	end
end

def probe_vts(vts_num)
	pd = probe_vts_data(vts_num)

	if $strict_length
		video_duration = measure_strict_duration(vts_num)
	else
		video_duration = measure_vob_duration(vts_num)
	end

	printf("VTS_%02d :", vts_num)

	if pd[:streams_v].size != 1
		fail "想定外のビデオストリーム数: #{pd[:streams_v].size}"
	end

	video = pd[:streams_v].first
	printf(" %dx%d(%s)", video[:width], video[:height], video[:display_aspect_ratio])
	printf(" %0.2ffps", Rational(video[:avg_frame_rate]).to_f)
	printf(" %s", video[:field_order])
	printf(" %s(%0.3fs)", sec2hhmmss(video_duration, full:true), video_duration)

	aux = ""
	#aux += sprintf(" angle:%d", pd[:angles])  if track[:angles] != 1
	aux += sprintf(" audio:%d", pd[:streams_a].size)  if pd[:streams_a].size != 1
	aux += sprintf(" subt:%d", pd[:streams_s].size)  if pd[:streams_s].size != 0
	aux += sprintf(" chpt:%d", pd[:chapters].size)  if pd[:chapters].size != 1
	print(" /" + aux)  if !aux.empty?
	print("\n")

	pd[:disc][:track].each do |title|
		next  if title[:vts] != vts_num
		if title[:angles] != 1
			printf("Angle %d :", 1)
			print(" 複数アングルがあります\n")
		end
	end

	pd[:streams_a].each.with_index(1) do |audio, ix|
		printf("Audio %d :", ix)
		printf(" %s %s %dHz %dch", audio[:language], audio[:codec_long_name], audio[:sample_rate], audio[:channels])
		printf(" %s", audio[:content])  if audio[:content] && !audio[:content].empty? && audio[:content] != "Undefined"
		print("\n")
	end

	pd[:streams_s].each.with_index(1) do |subp, ix|
		printf("Subtitle %d :", ix)
		printf(" %s", subp[:language])
		printf(" %s", subp[:content])  if subp[:content] && !subp[:content].empty? && subp[:content] != "Undefined"
		print("\n")
	end

	pd[:chapters].each.with_index(1) do |chapter, ix|
		printf("Chapter %d :", ix)
		printf(" %s - %s %s(%0.3fs)", sec2hhmmss(chapter[:start], full:true), sec2hhmmss(chapter[:end], full:true),
		 							sec2hhmmss(chapter[:length]), chapter[:length])
		print("\n")
	end

	pd[:disc][:track].each do |title|
		next  if title[:vts] != vts_num

		if title[:angles] > pd[:streams_v].size
			printf("タイトル%dのアングルは%d個ですが、ビデオストリームは%d個しかありません\n",
				title[:ix], title[:angles], pd[:streams_v].size)
		end
		if title[:audio].size > pd[:streams_a].size
			printf("タイトル%dのオーディオチャネルは%d個ですが、オーディオストリームは%d個しかありません\n",
				title[:ix], title[:audio].size, pd[:streams_a].size)
		end
		if title[:subp].size > pd[:streams_s].size
			printf("タイトル%dの字幕数は%d個ですが、字幕ストリームは%d個しかありません\n",
				title[:ix], title[:subp].size, pd[:streams_s].size)
		end
	end
end

def dvd2mp4(vts_num)
	pd = probe_vts_data(vts_num)

	# ファイルのメタ情報を決定
	if !$metadata[:album_name]
		if pd[:disc][:title] && pd[:disc][:title] != "unknown"
			$stdout.printf("アルバム名が指定されていません: ディスク情報から得た %s とします\n", pd[:disc][:title])
			$metadata[:album_name] = pd[:disc][:title]
		# else
		# 	$stdout.printf("アルバム名が指定されていません\n")
		end
	end

	if !$metadata[:title_name]
		$stdout.printf("タイトルが指定されていません\n")
	end

	# if !$metadata[:title_num]
	# 	$stdout.printf("タイトル番号が指定されていません\n")
	# end

	# 出力ファイル名を生成
	if $metadata[:title_name]
		if $metadata[:title_num]
			dst_basename = "#{$metadata[:title_num]} #{$metadata[:title_name]}".strip
		else
			dst_basename = "#{$metadata[:title_name]}"
		end
	else
		dst_basename = sprintf("VTS_%02d", vts_num)
	end

	# 開始:終了位置を決定
	framerate = Rational(pd[:streams_v].first[:avg_frame_rate])
	$start_sec = $start_pos ? pos2sec($start_pos, framerate) : nil
	$end_sec = $end_pos ? pos2sec($end_pos, framerate) : nil
	$duration_sec = $duration ? pos2sec($duration, framerate) : nil

	if $start_sec || $end_sec || $duration_sec
		$start_sec = 0  if !$start_sec
		if $end_sec
			$duration_sec = $end_sec - $start_sec
		elsif $duration_sec
			$end_sec = $start_sec + $duration_sec
		end
	end

	# ストリームのタイトル等を決定
	deinterlace = false
	pd[:streams_v].each_with_index do |stream, ix|
		if stream[:field_order] && stream[:field_order] != "progressive"
			deinterlace = true
		end
		title = $metadata[:s_video_name][ix]
		# if !title
		# 	$stdout.printf("ビデオストリーム #{ix+1} のタイトルが指定されていません\n")
		# 	title = "#{stream[:codec_long_name]} #{stream[:width]}x#{stream[:height]} #{stream[:display_aspect_ratio]}".strip
		# end
		stream[:title] = title
	end

	pd[:streams_a].each_with_index do |stream, ix|
		title = $metadata[:s_audio_name][ix]
		if !title
			$stdout.printf("オーディオストリーム #{ix+1} のタイトルが指定されていません\n")
			if stream[:lang]
				title = "#{stream[:language]} #{stream[:channel_layout]}".strip
			else
				title = "#{stream[:channel_layout]}".strip
			end
		else
			if !stream[:lang]
				stream[:lang] = guess_lang(title)
			end
		end
		stream[:title] = title
	end

	pd[:streams_s].each_with_index do |stream, ix|
		title = $metadata[:s_subtitle_name][ix]
		if !title
			$stdout.printf("字幕ストリーム #{ix+1} のタイトルが指定されていません\n")
			title = "#{stream[:language]}"
		else
			if !stream[:lang]
				stream[:lang] = guess_lang(title)
			end
		end
		stream[:title] = title
	end

	# 出力するストリームの数を種類ごとに数える
	streams_v_output = pd[:streams_v].count { |s| s[:title] != "omit" }
	streams_a_output = pd[:streams_a].count { |s| s[:title] != "omit" }
	streams_s_output = pd[:streams_s].count { |s| s[:title] != "omit" }

	# 指定長より短いチャプターは削除
	pd[:chapters].delete_if { |c| c[:length] < $delete_chpt_sec }

	# チャプター名
	pd[:chapters].each_with_index do |chapter, ix|
		title = $metadata[:chapter_name][ix]
		if !title
			$stdout.printf("チャプター #{ix+1} のタイトルが指定されていません\n")
			title = nil
		end
		chapter[:title] = title
	end

	# 出力対象のチャプター数を数える
	chapters_output = pd[:chapters].count { |c| c[:title] != "omit" }

	# チャプター情報ファイルを作成
	cfile = Tempfile.new(["chapter", ".txt"])
	cfile.printf(";FFMETADATA1\n")
	if !$split_chapter && chapters_output >= 2
		pd[:chapters].each.with_index(1) do |chapter, ix|
			next  if chapter[:title] == "omit"
			next  if $start_sec && chapter[:end] <= ($start_sec + 0.5)
			next  if $end_sec && chapter[:start] >= ($end_sec - 0.5)

			cfile.printf("[CHAPTER]\n")
			cfile.printf("TIMEBASE=1/1000000\n")
			cfile.printf("START=%d\n", chapter[:start] * 1000000)
			cfile.printf("END=%d\n", chapter[:end] * 1000000)

			title = chapter[:title]
			if title && !title.empty?
				cfile.printf("title=%s\n", title)
			end
		end
	end
	cfile.flush
	system("cat", cfile.path)  if $dryrun

	# 対象VOB,IFOの決定
	vobfiles = pd[:vobfiles]
	ifofiles = pd[:ifofiles]
	ifofile = ifofiles.first

	# 変換本体

	cmd1 = ["cat"]
	cmd1 += vobfiles

	cmd2 = [FFMPEG_CMD]
	cmd2 += ["-hide_banner"]
	cmd2 += ["-loglevel", "info"]
	cmd2 += ["-analyzeduration", FF_ANALYZEDURATION]
	cmd2 += ["-probesize", FF_PROBESIZE]
	cmd2 += ["-y"]  if $overwrite
	cmd2 += ["-ifo_palette", ifofile]  if ifofile
	cmd2 += ["-i", "-"]
	cmd2 += ["-i", cfile.path]
	cmd2 += ["-map_chapters", "1"]

	# cmd2 += ["-max_muxing_queue_size", "2048"]
	cmd2 += ["-f", "mp4"]
	cmd2 += ["-movflags", "faststart"]

	if streams_v_output >= 1
		cmd2 += ["-preset:v", $preset]
		cmd2 += ["-crf:v", $crf.to_s]
		cmd2 += ["-tune:v", $video_tune]  if $video_tune
		cmd2 += ["-vf:v", "bwdif"]  if deinterlace
	end

	if streams_a_output >= 1
		if $flac_audio
			cmd2 += ["-codec:a", "flac", "-strict", "experimental"]
		else
			cmd2 += ["-codec:a", "libfdk_aac"]
			cmd2 += ["-profile:a", "aac_low"]
		end
	end

	if streams_s_output >= 1
		cmd2 += ["-codec:s", "dvd_subtitle"]
	end

	cmd2 += ["-metadata", "album=#{$metadata[:album_name]}"]  if $metadata[:album_name]
	cmd2 += ["-metadata", "track=#{$metadata[:title_num]}"]  if $metadata[:title_num]
	cmd2 += ["-metadata", "title=#{$metadata[:title_name]}"]  if $metadata[:title_name]
	cmd2 += ["-metadata", "encoding_tool=#{$commandline}"]

	# 出力するストリームとストリーム毎のオプションを指定

	scount = 0

	pd[:streams_v].each do |stream|
		next  if stream[:title] == "omit"

		cmd2 += ["-map", stream[:ffid]]

		if streams_v_output >= 2
			cmd2 += ["-metadata:s:#{scount}", "language=#{stream[:lang]}"]
			cmd2 += ["-metadata:s:#{scount}", "title=#{stream[:title]}"]
			cmd2 += ["-metadata:s:#{scount}", "handler_name=#{stream[:title]}"]
		end

		scount += 1
	end

	pd[:streams_a].each do |stream|
		next  if stream[:title] == "omit"

		cmd2 += ["-map", stream[:ffid]]
		if $hq_audio
			cmd2 += ["-vbr:#{scount}", "5"]
		else
			cmd2 += ["-vbr:#{scount}", "3"]
			cmd2 += ["-cutoff:#{scount}", "18000"]
		end

		# if streams_a_output >= 2
			cmd2 += ["-metadata:s:#{scount}", "language=#{stream[:lang]}"]
			cmd2 += ["-metadata:s:#{scount}", "title=#{stream[:title]}"]
			cmd2 += ["-metadata:s:#{scount}", "handler_name=#{stream[:title]}"]
		# end

		scount += 1
	end

	pd[:streams_s].each do |stream|
		next  if stream[:title] == "omit"

		cmd2 += ["-map", stream[:ffid]]
		# if streams_s_output >= 2
			cmd2 += ["-metadata:s:#{scount}", "language=#{stream[:lang]}"]
			cmd2 += ["-metadata:s:#{scount}", "title=#{stream[:title]}"]
			cmd2 += ["-metadata:s:#{scount}", "handler_name=#{stream[:title]}"]
		# end

		scount += 1
	end

# TODO:サムネイル画像

	if $split_chapter
		if chapters_output < 1
			fail "出力対象のチャプターがひとつもありません"
		end

		pd[:chapters].each.with_index(1) do |chapter, ix|
			next  if chapter[:title] == "omit"

			cmd2c = cmd2.dup

			s = chapter[:start]
			s += $start_sec  if $start_sec
			cmd2c += ["-ss", "#{s}"]
			s = chapter[:length]
			s -= $start_sec  if $start_sec
			s = [s, $duration_sec].min if $duration_sec
			cmd2c += ["-t", "#{s}"]

			title = chapter[:title]
			if title
				if $metadata[:title_name]
					cmd2c += ["-metadata", "title=#{$metadata[:title_name]} #{title}".rstrip]
				else
					cmd2c += ["-metadata", "title=#{title}"]
				end
			else
				title = "#{ix}"
			end
			dst_filename = dst_basename + " " + title + ".mp4"

			if $dryrun
				p cmd1
				p cmd2c + [dst_filename]
			else
				cmd2c += [dst_filename]
				Open3.pipeline(cmd1, cmd2c)

				if File.exist?(dst_filename)
					timestamp_src = (ifofiles + vobfiles).first
					atime = File.atime(timestamp_src)
					mtime = File.mtime(timestamp_src)
					File.utime(atime, mtime, dst_filename)
				end
			end
		end
	else
		cmd2 += ["-ss", $start_sec.to_s]  if $start_sec
		cmd2 += ["-t", $duration_sec.to_s]  if $duration_sec
		dst_filename = dst_basename + ".mp4"

		if $dryrun
			p cmd1
			p cmd2 + [dst_filename]
		else
			cmd2 += [dst_filename]
			Open3.pipeline(cmd1, cmd2)

			if File.exist?(dst_filename)
				timestamp_src = (ifofiles + vobfiles).first
				atime = File.atime(timestamp_src)
				mtime = File.mtime(timestamp_src)
				File.utime(atime, mtime, dst_filename)
			end
		end
	end
end

def myShellwordsJoin(args)
	def q(s)
		if s =~ /[\s;&()|^<>?*\[\]$`"\\!{}]/
			return "'" + s.gsub("'") { "'\\''" } + "'"
		else
			return s.gsub("'") { "\\'" }
		end
	end

	return args.map { |a|
		(a =~ /^(--.+=)(.*)$/) ? q($1) + q($2) : q(a)
	}.join(" ")
end

def main(args)
	var_init
	$commandline = ProgName + " " + myShellwordsJoin(args)

	args.options do |opt|
		opt.banner = "#{ProgName} v#{Version} #{Copyright}\n" +
						"Usage: #{ProgName} [options] VTS_nn..."

		$probe = false
		opt.on("-p", "--[no-]probe",
			"ファイルの情報を表示する") do |v|
			$probe = v
		end

		$probe_raw = false
		opt.on("-r", "--[no-]probe-raw",
			"ファイルの情報を表示する(非編集)") do |v|
			$probe_raw = v
		end

		$crf = 20.0
		opt.on("--crf=n", Float,
			"VBR画質を指定する(0:ロスレス - 20.0:デフォルト - 51:低)") do |v|
			$crf = v
		end

		$start_pos = nil
		$start_sec = nil
		opt.on("-s", "--startpoint=pos", String,
			"開始位置を指定する(秒/時分秒/フレーム)") do |v|
			$start_pos = v
		end

		$end_pos = nil
		$end_sec = nil
		opt.on("-e", "--endpoint=pos", String,
			"終了位置を指定する") do |v|
			$end_pos = v
		end

		$duration = nil
		$duration_sec = nil
		opt.on("-d", "--duration=dur", String,
			"出力する長さを指定する") do |v|
			$duration = v
		end

		$split_chapter = false
		opt.on("--[no-]split-chapter",
			"チャプターごとに分割して出力する") do |v|
			$split_chapter = v
		end

		$metadata[:album_name] = nil
		opt.on("--album-name=str", String,
			"アルバム名を指定") do |v|
			$metadata[:album_name] = v
		end

		$metadata[:title_num] = nil
		opt.on("--title-num=n", String,
			"タイトル番号を指定") do |v|
			$metadata[:title_num] = v
		end

		$metadata[:title_name] = nil
		opt.on("-t", "--title=str", String,
			"タイトルを指定") do |v|
			$metadata[:title_name] = v
		end

		$metadata[:s_video_name] = []
		opt.on("--title:v=str", String,
			"ビデオストリームのタイトルを指定('omit'で出力しない/'auto'で自動)") do |v|
			v = nil  if v == "auto"
			$metadata[:s_video_name] << v
		end

		$metadata[:s_audio_name] = []
		opt.on("--title:a=str", String,
			"オーディオストリームのタイトルを指定") do |v|
			v = nil  if v == "auto"
			$metadata[:s_audio_name] << v
		end

		$metadata[:s_subtitle_name] = []
		opt.on("--title:s=str", String,
			"字幕ストリームのタイトルを指定") do |v|
			v = nil  if v == "auto"
			$metadata[:s_subtitle_name] << v
		end

		$metadata[:chapter_name] = []
		opt.on("--title:c=str", String,
			"チャプタータイトルを指定") do |v|
			v = nil  if v == "auto"
			$metadata[:chapter_name] << v
		end

		$delete_chpt_sec = 0
		opt.on("--delete-short-chapter=n", Float,
			"n秒より短いチャプターマークを削除する") do |v|
			$delete_chpt_sec = v
		end

		$video_tune = nil
		opt.on("--tune:v=str", String,
			"ビデオの種類(film|animation|grain|stillimage...)") do |v|
			$video_tune = v
		end

		$preset = "veryslow"
		opt.on("-u", "--ultrafast",
			"ビデオプリセット ultrafast") do
			$preset = "ultrafast"
		end


		$hq_audio = false
		opt.on("-y", "--[no-]hqaudio",
			"高音質でエンコードする") do |v|
			$hq_audio = v
		end

		$flac_audio = false
		opt.on("-y", "--[no-]flacaudio",
			"音声をFLACでエンコードする") do |v|
			$flac_audio = v
		end

		$adjust_fps = true
		opt.on("--[no-]adjust-fps",
			"チャプター時間のfps調整を行う") do |v|
			$adjust_fps = v
		end

		$strict_length = false
		opt.on("--[no-]strict-length",
			"再生時間を厳密に測定する") do |v|
			$strict_length = v
		end

		$overwrite = false
		opt.on("-y", "--[no-]overwrite",
			"出力ファイルが既に存在しても上書きする") do |v|
			$overwrite = v
		end

		$dryrun = false
		opt.on("--[no-]dry-run",
			"変換処理を実際には行わない") do |v|
			$dryrun = v
		end

		opt.parse!

		if args.empty?
			if $probe_raw
				pp probe_disc_data_raw
			elsif $probe
				probe_disc
			else
				print(opt.help)
			end
		else
			args.each do |arg|
				vts_num = vts_num_to_i(arg)
				if $probe_raw
					pp probe_vts_data_raw(vts_num)
				elsif $probe
					probe_vts(vts_num)
				else
					dvd2mp4(vts_num)
				end
			end
		end
	end

	return $rcode
end

exit main(ARGV)
