#! /usr/bin/ruby -E:UTF-8
# -*- mode:Ruby; tab-width:4; coding:UTF-8; -*-
# vi:set ft=ruby ts=4 fenc=UTF-8 :
#----------------------------------------------------------------
# DVD IFO VOBをmp4に変換する
#
# 2020/06/14 opa
#----------------------------------------------------------------
ProgName = "dvd2mp4"
Version = "0.01"
#=====dpk===== Copyright2020
Copyright = "Copyright (c) 2020 by opa"
#=====dpk=====
FFMPEG_CMD = "ffmpeg"
FFPROBE_CMD = "ffprobe"
LSDVD_CMD = "lsdvd"

LANGTABLE = {
	"ja" => "jpn",
	"xx" => "",
}

require 'optparse'
require 'open3'
require 'json'
require 'tempfile'
require 'pp'

def var_init
	$PROGRAM_NAME = ProgName
	$metadata = {}
	$rcode = 0
end

def sec2hhmmss(sec, full:false)
	r = ""
	d, m = sec.divmod(1) # 秒以下
	r = sprintf(".%03d", (m * 1000).round)  if m != 0 || full
	d, m = d.divmod(60) # 秒
	r = sprintf("%02d", m) + r
	if d > 0 || full
		d, m = d.divmod(60) # 分
		r = sprintf("%02d:", m) + r
	end
	if d > 0 || full
		d, m = d.divmod(60) # 時
		r = sprintf("%02d:", m) + r
	end
	return r
end

def pos2sec(pos, fr=29.97)
	case pos
	when /^(\d+)f$/
		return $1.to_f * (1.0 / fr)
	when /^(\d+):(\d+):(\d+(?:\.\d*)?)$/
		return $1.to_i * 3600 + $2.to_i * 60 + $3.to_f
	when /^(\d+):(\d+(?:\.\d*)?)$/
		return $1.to_i * 60 + $2.to_f
	when /^(\d+(?:\.\d*)?s?)$/
		return $1.to_f
	else
		fail "位置の指定が不正です: #{pos}"
	end
end

def title_num_to_i(title_num)
	if title_num =~ /$VTS_(\d+)$/i
		i = $1.to_i
	else
		i = title_num.to_i
	end
	if i < 1
		fail "タイトル番号の指定が不正です: #{title_num}"
	end
	return i
end

def probe_disc_data
	cmd = [LSDVD_CMD]
	cmd += ["-x"]
	cmd += ["-Or", "."]
	r = Open3.capture3(*cmd)

	if r[0] == ""
		printf("%s\n", r[1])
		fail "lsdvdの実行に失敗しました"
	end

	return eval(r[0])
end

def probe_title_data(title_num)
	lsdvd_data = probe_disc_data

	track_data = lsdvd_data[:track].find { |t| t[:ix] == title_num }
	if !track_data
		$stderr.printf("タイトル番号%dの情報はありません\n", title_num)
		$rcode = 1
		fail
	end
	vts_num = track_data[:vts].to_i
	if !vts_num
		$stderr.printf("タイトル番号%dに対応するvts番号がありません\n", title_num)
		$rcode = 1
		fail
	end

	vts_chapters = []
	lsdvd_data[:track].each do |track|
		if track[:vts] == vts_num
			track[:chapter].each do |chapter|
				cell = track[:cell].find { |c| c[:ix] == chapter[:startcell] }
				if !vts_chapters.find { |c|
					c[:length] == chapter[:length] &&
					c[:first_sector] == cell[:first_sector] &&
					c[:last_sector] == cell[:last_sector]
				}
					vts_chapters << {
						title: track[:ix],
						ttn: track[:ttn],
						ix: chapter[:ix],
						length: chapter[:length],
						first_sector: cell[:first_sector],
						last_sector: cell[:last_sector],
					}
				end
			end
		end
	end
	vts_chapters.sort_by! { |c| c[:first_sector] }
	ctmap = {0 => 0.0}
	ccount = 0
	vts_chapters.each do |chapter|
		ccount += 1
		chapter[:ix] = ccount
		chapter[:start] = ctmap[chapter[:first_sector]].round(6)
		ctmap[chapter[:last_sector] + 1] = chapter[:start] + chapter[:length]
		chapter[:end] = ctmap[chapter[:last_sector] + 1].round(6)
	end

	vobfiles = Dir.glob(sprintf("VTS_%02d_*.VOB", vts_num)).sort
	if $skipvob
		vobfiles.shift($skipvob)
	else
		vobfiles.shift  if vobfiles.first =~ /^VTS_\d+_0\.VOB/i
	end
	fail "入力VOBファイルがひとつもありません"  if vobfiles.empty?

	cmd1 = ["cat"]
	cmd1 += vobfiles

	cmd2 = [FFPROBE_CMD]
	cmd2 += ["-hide_banner"]
	cmd2 += ["-loglevel", "error"]
	cmd2 += ["-analyzeduration", "120M"]
	cmd2 += ["-probesize", "120M"]
	cmd2 += ["-print_format", "json"]
	cmd2 += ["-show_format"]
	cmd2 += ["-show_streams"]
	cmd2 += ["-"]
	ffprobe_data = JSON.parse(Open3.pipeline_r(cmd1, cmd2)[0].read, symbolize_names:true)

	return {
		ffprobe:ffprobe_data,
		lsdvd:lsdvd_data,
		lsdvd_track_data:track_data,
		vts:vts_num,
		vts_chapters:vts_chapters,
	}
end

def probe_disc
	lsdvd = probe_disc_data

	printf("disc title : %s\n", lsdvd[:title])
#	printf("vmg_id : %s\n", lsdvd[:vmg_id])
	printf("provider id : %s\n", lsdvd[:provider_id])
	printf("longest title : %d\n", lsdvd[:longest_track])  if lsdvd[:track].size > 1

	lsdvd[:track].each do |track|
		printf("Title %d : VTS_%02d-%d", track[:ix], track[:vts], track[:ttn])
		printf(" %dx%d(%s) %0.2ffps %0.1fs", track[:width], track[:height], track[:aspect], track[:fps], track[:length])
		printf("(%s)", sec2hhmmss(track[:length]))  if track[:length] > 60
		aux = ""
		aux += sprintf(" angle:%d", track[:angles])  if track[:angles] != 1
		aux += sprintf(" chpt:%d", track[:chapter].size)  if track[:chapter].size != 1
		aux += sprintf(" audio:%d", track[:audio].size)  if track[:audio].size != 1
		aux += sprintf(" subt:%d", track[:subp].size)  if track[:subp].size != 0
		print(" /" + aux)  if !aux.empty?
		print("\n")
	end
end

def probe_title(title_num)
	title_num = title_num_to_i(title_num)

	probe_data = probe_title_data(title_num)
	lsdvd = probe_data[:lsdvd]
	track = probe_data[:lsdvd_track_data]

	printf("Title %d : VTS_%02d-%d", track[:ix], track[:vts], track[:ttn])
	printf(" %dx%d(%s) %0.2ffps %0.1fs", track[:width], track[:height], track[:aspect], track[:fps], track[:length])
	printf("(%s)", sec2hhmmss(track[:length]))  if track[:length] > 60
	aux = ""
	aux += sprintf(" angle:%d", track[:angles])  if track[:angles] != 1
	aux += sprintf(" chpt:%d", track[:chapter].size)  if track[:chapter].size != 1
	aux += sprintf(" audio:%d", track[:audio].size)  if track[:audio].size != 1
	aux += sprintf(" subt:%d", track[:subp].size)  if track[:subp].size != 0
	print(" /" + aux)  if !aux.empty?
	print("\n")

	if track[:angles] != 1
		printf("Angle %d :", 1)
		print(" 複数アングルがあります\n")
	end

	probe_data[:vts_chapters].each_with_index do |chapter, i|
		printf("Chapter %d :", i + 1)
		printf(" %s - %s %0.3fs", sec2hhmmss(chapter[:start], full:true), sec2hhmmss(chapter[:end], full:true), chapter[:length])
		printf("(%s)", sec2hhmmss(chapter[:length]))  if chapter[:length] > 60
		printf(" (other title)")  if chapter[:title] != title_num
		print("\n")
	end

	track[:audio].each do |audio|
		printf("Audio %d :", audio[:ix])
		printf(" %s %s %dHz %s %dch", audio[:language], audio[:format], audio[:frequency], audio[:quantization], audio[:channels])
		printf(" %s", audio[:content])  if !audio[:content].empty? && audio[:content] != "Undefined"
		print("\n")
	end

	track[:subp].each do |subp|
		printf("Subtitle %d :", subp[:ix])
		printf(" %s", subp[:language])
		printf(" %s", subp[:content])  if !subp[:content].empty? && subp[:content] != "Undefined"
		print("\n")
	end
end

def dvd2mp4(title_num)
	title_num = title_num_to_i(title_num)
	probe_data = probe_title_data(title_num)
	track_data = probe_data[:lsdvd_track_data]

	# ファイルのメタ情報を決定

	if !$metadata[:album_name]
		if probe_data[:lsdvd][:title] && probe_data[:lsdvd][:title] != "unknown"
			$metadata[:album_name] = probe_data[:lsdvd][:title]
			$stdout.printf("アルバム名が指定されていません: ディスク情報から得た %s とします\n", $metadata[:album_name])
		else
			$stdout.printf("アルバム名が指定されていません\n")
		end
	end

	if !$metadata[:title_name]
		$stdout.printf("タイトルが指定されていません\n")
	end

	if !$metadata[:title_num]
		$stdout.printf("タイトル番号が指定されていません\n")
	end

	# 開始:終了位置を決定
	framerate = track_data[:fps]
	$start_sec = $start_pos ? pos2sec($start_pos, framerate) : nil
	$end_sec = $end_pos ? pos2sec($end_pos, framerate) : nil
	$duration_sec = $duration ? pos2sec($duration, framerate) : nil

	if $start_sec || $end_sec || $duration_sec
		$start_sec = 0  if !$start_sec
		if $end_sec
			$duration_sec = $end_sec - $start_sec
		elsif $duration_sec
			$end_sec = $start_sec + $duration_sec
		end
	end

	# ストリームのマッピングを決定

	streams_v = []
	streams_v_count = 0
	streams_a = []
	streams_a_count = 0
	streams_s = []
	streams_s_count = 0
	for stream_num in 1..999
		stream = probe_data[:ffprobe][:streams].find { |s| s[:index] == stream_num }
		break  if !stream

		stream[:ffid] = "0:#{stream_num}"

		case stream[:codec_type]
		when "video"
			streams_v_count += 1
			streams_v << stream

			title = $metadata[:s_video_name][streams_v_count - 1]
			if !title
				# $stdout.printf("ビデオストリーム #{streams_v_count} のタイトルが指定されていません\n")
				title = "#{stream[:codec_long_name]} #{stream[:width]}x#{stream[:height]} #{stream[:display_aspect_ratio]}"
			end
			stream[:title] = title
		when "audio"
			streams_a_count += 1
			streams_a << stream

			lsdvd_data = track_data[:audio].find { |s| s[:ix] == streams_a_count }
			lsdvd_data = track_data[:audio].first  if !lsdvd_data
			if lsdvd_data && lsdvd_data[:langcode]
				stream[:lang] = LANGTABLE[lsdvd_data[:langcode]]
			end
			if !stream[:lang]
				$stderr.printf("言語情報が取得できません: %s\n", lsdvd_data[:langcode])
				$rcode = 1
				fail
			end

			title = $metadata[:s_audio_name][streams_a_count - 1]
			if !title
				$stdout.printf("オーディオストリーム #{streams_a_count} のタイトルが指定されていません\n")
				title = "#{lsdvd_data[:language]} #{stream[:channel_layout]}"
			end
			stream[:title] = title
		when "subtitle"
			streams_s_count += 1
			streams_s << stream

			lsdvd_data = track_data[:subp].find { |s| s[:ix] == streams_s_count }
			lsdvd_data = track_data[:subp].first  if !lsdvd_data
			if lsdvd_data && lsdvd_data[:langcode]
				stream[:lang] = LANGTABLE[lsdvd_data[:langcode]]
			end
			if !stream[:lang]
				$stderr.printf("言語情報が取得できません: %s\n", lsdvd_data[:langcode])
				$rcode = 1
				fail
			end

			title = $metadata[:s_subtitle_name][streams_s_count - 1]
			if !title
				$stdout.printf("字幕ストリーム #{streams_s_count} のタイトルが指定されていません\n")
				title = "#{lsdvd_data[:language]}"
			end
			stream[:title] = title
		end
	end

	# 出力するストリームの数を種類ごとに数える

	streams_v_output = 0
	streams_v.each do |stream|
		if stream[:title] != "omit"
			streams_v_output += 1
		end
	end

	streams_a_output = 0
	streams_a.each do |stream|
		if stream[:title] != "omit"
			streams_a_output += 1
		end
	end

	streams_s_output = 0
	streams_s.each do |stream|
		if stream[:title] != "omit"
			streams_s_output += 1
		end
	end

	# チャプター情報を決定

	# 指定長より短いチャプターは削除
	probe_data[:vts_chapters].delete_if { |c| c[:length] < $delete_chpt_sec }

	# 出力対象のチャプター数を数える
	chapters_output = 0
	probe_data[:vts_chapters].each_with_index do |chapter, i|
		if $metadata[:chapter_name][i] != "omit"
			chapters_output += 1
		end
	end

	cfile = Tempfile.new(["chapter", ".txt"])
	cfile.printf(";FFMETADATA1\n")
	if !$split_chapter && chapters_output > 1
		probe_data[:vts_chapters].each_with_index do |chapter, i|
			next  if $metadata[:chapter_name][i] == "omit"
			next  if $start_sec && chapter[:end] <= ($start_sec + 0.5)
			next  if $end_sec && chapter[:start] >= ($end_sec - 0.5)

			cfile.printf("[CHAPTER]\n")
			cfile.printf("TIMEBASE=1/1000000\n")
			cfile.printf("START=%d\n", chapter[:start] * 1000000)
			cfile.printf("END=%d\n", chapter[:end] * 1000000)

			title = $metadata[:chapter_name][i]
			if !title
				$stdout.printf("チャプター #{i+1} のタイトルが指定されていません\n")
				# title = "Chapter #{i+1}"
			end
			cfile.printf("title=%s\n", title)  if title && !title.empty?
		end
	end
	cfile.flush
	# system("cat", cfile.path)

	# 対象VOB,IFOの決定

	vts_num = probe_data[:vts]
	vobfiles = Dir.glob(sprintf("VTS_%02d_*.VOB", vts_num)).sort
	if $skipvob
		vobfiles.shift($skipvob)
	else
		vobfiles.shift  if vobfiles.first =~ /^VTS_\d+_0\.VOB/i
	end
	fail "入力VOBファイルが0個です"  if vobfiles.empty?
	ifofiles = Dir.glob(sprintf("VTS_%02d_*.IFO", vts_num)).sort
	ifofile = ifofiles.empty? ? nil : ifofiles.first

	# 変換本体

	cmd1 = ["cat"]
	cmd1 += vobfiles

	cmd2 = [FFMPEG_CMD]
	cmd2 += ["-hide_banner"]
	cmd2 += ["-loglevel", "info"]
	cmd2 += ["-analyzeduration", "120M"]
	cmd2 += ["-probesize", "120M"]
	cmd2 += ["-y"]  if $overwrite
	cmd2 += ["-ifo_palette", ifofile]  if ifofile
	cmd2 += ["-i", "-"]

	cmd2 += ["-i", cfile.path]
	cmd2 += ["-map_chapters", "1"]

	cmd2 += ["-f", "mp4"]
	cmd2 += ["-preset", "veryslow"]
	cmd2 += ["-vf", "bwdif"]  if $deinterlace
	cmd2 += ["-codec:a", "flac", "-strict", "-2"]  if $flac_audio
	cmd2 += ["-b:a", "256000"]  if $hq_audio
	cmd2 += ["-codec:s", "dvd_subtitle"]
	cmd2 += ["-movflags", "faststart"]
	cmd2 += ["-crf", $crf.to_s]

	cmd2 += ["-metadata", "album=#{$metadata[:album_name]}"]  if $metadata[:album_name]
	cmd2 += ["-metadata", "track=#{$metadata[:title_num]}"]  if $metadata[:title_num]
	cmd2 += ["-metadata", "title=#{$metadata[:title_name]}"]  if $metadata[:title_name]

	# 出力するストリームを指定

	scount = 0

	streams_v.each do |stream|
		if stream[:title] != "omit"
			cmd2 += ["-map", stream[:ffid]]
			if streams_v_output > 1
				cmd2 += ["-metadata:s:#{scount}", "language=#{stream[:lang]}"]
				cmd2 += ["-metadata:s:#{scount}", "title=#{stream[:title]}"]
				cmd2 += ["-metadata:s:#{scount}", "handler_name=#{stream[:title]}"]
			end
		end
		scount += 1
	end

	streams_a.each do |stream|
		if stream[:title] != "omit"
			cmd2 += ["-map", stream[:ffid]]
			# if streams_a_output > 1
				cmd2 += ["-metadata:s:#{scount}", "language=#{stream[:lang]}"]
				cmd2 += ["-metadata:s:#{scount}", "title=#{stream[:title]}"]
				cmd2 += ["-metadata:s:#{scount}", "handler_name=#{stream[:title]}"]
			# end
		end
		scount += 1
	end

	streams_s.each do |stream|
		if stream[:title] != "omit"
			cmd2 += ["-map", stream[:ffid]]
			# if streams_s_output > 1
				cmd2 += ["-metadata:s:#{scount}", "language=#{stream[:lang]}"]
				cmd2 += ["-metadata:s:#{scount}", "title=#{stream[:title]}"]
				cmd2 += ["-metadata:s:#{scount}", "handler_name=#{stream[:title]}"]
			# end
		end
		scount += 1
	end

# TODO:サムネイル画像

	# 出力ファイル名を生成
	if $metadata[:title_name]
		if $metadata[:title_num]
			dst_basename = "#{$metadata[:title_num]} #{$metadata[:title_name]}"
		else
			dst_basename = "#{$metadata[:title_name]}"
		end
	else
		dst_basename = sprintf("title_%02d", title_num)
	end

	if $split_chapter
		if chapters_output < 1
			fail "出力対象のチャプターがひとつもありません"
		end

		probe_data[:vts_chapters].each_with_index do |chapter, i|
			if $metadata[:chapter_name][i] != "omit"
				cmd2c = cmd2.dup

				s = chapter[:start]
				s += $start_sec  if $start_sec
				cmd2c += ["-ss", "#{s}"]
				s = chapter[:length]
				s = [s, $duration_sec].min if $duration_sec
				cmd2c += ["-t", "#{s}"]

				title = $metadata[:chapter_name][i]
				if title
					if $metadata[:title_name]
						cmd2c += ["-metadata", "title=#{$metadata[:title_name]} #{$metadata[:chapter_name][i]}"]
					else
						cmd2c += ["-metadata", "title=#{$metadata[:chapter_name][i]}"]
					end
				end
				title = "#{i+1}" if !title
				dst_filename = dst_basename + " " + title + ".mp4"

				if $dryrun
					p cmd1
					p cmd2c + [dst_filename]
				else
					cmd2c += [dst_filename]
					Open3.pipeline(cmd1, cmd2c)

					if File.exist?(dst_filename)
						timestamp_src = (ifofiles + vobfiles).first
						atime = File.atime(timestamp_src)
						mtime = File.mtime(timestamp_src)
						File.utime(atime, mtime, dst_filename)
					end
				end
			end
		end
	else
		cmd2 += ["-ss", $start_sec.to_s]  if $start_sec
		cmd2 += ["-t", $duration_sec.to_s]  if $duration_sec
		dst_filename = dst_basename + ".mp4"

		if $dryrun
			p cmd1
			p cmd2 + [dst_filename]
		else
			# if !$encode_2pass
				cmd2 += [dst_filename]
				Open3.pipeline(cmd1, cmd2)
			# else
			# 	cmd2_1 = cmd2.dup
			# 	cmd2_1 += ["-an", "-pass", "1", "NUL"]
			# 	cmd2_2 = cmd2.dup
			# 	cmd2_2 += ["-pass", "2", dst_filename]
			#
			# 	Open3.pipeline(cmd1, cmd2_1)
			# 	Open3.pipeline(cmd1, cmd2_2)
			# end

			if File.exist?(dst_filename)
				timestamp_src = (ifofiles + vobfiles).first
				atime = File.atime(timestamp_src)
				mtime = File.mtime(timestamp_src)
				File.utime(atime, mtime, dst_filename)
			end
		end
	end
end

def main(args)
	var_init

	args.options do |opt|
		opt.banner = "#{ProgName} v#{Version} #{Copyright}\n" +
						"Usage: #{ProgName} [options] VTS_nn..."

		$probe = false
		opt.on("-p", "--[no-]probe",
			"ファイルの情報を表示する") do |v|
			$probe = v
		end

		$crf = 20.0
		opt.on("--crf=n", Float,
			"VBR画質を指定する(0:高 〜 20.0:デフォルト)") do |v|
			$crf = v
		end

		$start_pos = nil
		$start_sec = nil
		opt.on("-s", "--startpoint=pos", String,
			"開始位置を指定する(秒/時分秒/フレーム)") do |v|
			$start_pos = v
		end

		$end_pos = nil
		$end_sec = nil
		opt.on("-e", "--endpoint=pos", String,
			"終了位置を指定する") do |v|
			$end_pos = v
		end

		$duration = nil
		$duration_sec = nil
		opt.on("-d", "--duration=dur", String,
			"出力する長さを指定する") do |v|
			$duration = v
		end

		$split_chapter = false
		opt.on("--[no-]split-chapter",
			"チャプターごとに分割して出力する") do |v|
			$split_chapter = v
		end

		$metadata[:album_name] = nil
		opt.on("--album-name[=str]", String,
			"アルバム名を指定") do |v|
			$metadata[:album_name] = v
		end

		$metadata[:title_num] = nil
		opt.on("--title-num[=n]", String,
			"タイトル番号を指定") do |v|
			$metadata[:title_num] = v
		end

		$metadata[:title_name] = nil
		opt.on("--title[=str]", String,
			"タイトルを指定") do |v|
			$metadata[:title_name] = v
		end

		$metadata[:s_video_name] = []
		opt.on("--title:v[=str]", String,
			"ビデオストリームのタイトルを指定('omit'で出力しない)") do |v|
			$metadata[:s_video_name] << v
		end

		$metadata[:s_audio_name] = []
		opt.on("--title:a[=str]", String,
			"オーディオストリームのタイトルを指定") do |v|
			$metadata[:s_audio_name] << v
		end

		$metadata[:s_subtitle_name] = []
		opt.on("--title:s[=str]", String,
			"字幕ストリームのタイトルを指定") do |v|
			$metadata[:s_subtitle_name] << v
		end

		$metadata[:chapter_name] = []
		opt.on("--title:c[=str]", String,
			"チャプタータイトルを指定") do |v|
			$metadata[:chapter_name] << v
		end

		$delete_chpt_sec = 0
		opt.on("--delete-short-chapter=n", Float,
			"n秒より短いチャプターマークを削除する") do |v|
			$delete_chpt_sec = v
		end

		$deinterlace = false
		opt.on("--deinterlace[=flag]", TrueClass,
			"インターレース解除を行う") do
			$deinterlace = true
		end

		$hq_audio = false
		opt.on("-y", "--[no-]hqaudio",
			"高音質でエンコードする") do |v|
			$hq_audio = v
		end

		$flac_audio = false
		opt.on("-y", "--[no-]flacaudio",
			"音声をFLACでエンコードする") do |v|
			$flac_audio = v
		end

		$overwrite = false
		opt.on("-y", "--[no-]overwrite",
			"出力ファイルが既に存在しても上書きする") do |v|
			$overwrite = v
		end

		$encode_2pass = false
		# opt.on("--[no-]2pass",
		# 	"2パスエンコードを行う") do |v|
		# 	$encode_2pass = v
		# end

		$skipvob = nil
		# opt.on("--skipvobs=n", Integer,
		# 	"先頭のn個のVOBファイルをスキップする") do |v|
		# 	$skipvob = v
		# end

		$dryrun = false
		opt.on("--[no-]dry-run",
			"変換処理を実際には行わない") do |v|
			$dryrun = v
		end

		opt.parse!

		if args.empty?
			if $probe
				probe_disc
			else
				print(opt.help)
			end
		else
			args.each do |arg|
				if $probe
					probe_title(arg)
				else
					dvd2mp4(arg)
				end
			end
		end
	end

	return $rcode
end

exit main(ARGV)
