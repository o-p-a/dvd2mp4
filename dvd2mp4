#! /usr/bin/ruby -E:UTF-8
# -*- mode:Ruby; tab-width:4; coding:UTF-8; -*-
# vi:set ft=ruby ts=4 fenc=UTF-8 :
#----------------------------------------------------------------
# DVD IFO VOBをmp4に変換する
#
# 2020/06/14 opa
#----------------------------------------------------------------
ProgName = "dvd2mp4"
Version = "1.01"
#=====dpk===== Copyright2020
Copyright = "Copyright (c) 2020 by opa"
#=====dpk=====
FFMPEG_CMD = "ffmpeg"
FFPROBE_CMD = "ffprobe"
LSDVD_CMD = "lsdvd"

LANGTABLE = {
	"ja" => "jpn",
	"en" => "eng",
	"fr" => "fra",
	"xx" => nil,
}

FF_ANALYZEDURATION = "600M" # 10min
FF_PROBESIZE = "450M" # 450MB

require 'optparse'
require 'open3'
require 'json'
require 'tempfile'
require 'shellwords'
require 'pp'

def var_init
	$PROGRAM_NAME = ProgName
	$metadata = {}
	$rcode = 0
end

def myShellwordsJoin_q(s)
	if s =~ /[\s;&()|^<>?*\[\]$`"\\!{}]/
		return "'" + s.gsub("'") { "'\\''" } + "'"
	else
		return s.gsub("'") { "\\'" }
	end
end

def myShellwordsJoin(args)
	return args.map { |a|
		(a =~ /^(--.+=)(.*)$/) ? myShellwordsJoin_q($1) + myShellwordsJoin_q($2) : myShellwordsJoin_q(a)
	}.join(" ")
end

def sec2hhmmss(sec, full:false)
	r = ""
	d, m = sec.divmod(1) # 秒以下
	r = sprintf(".%03d", (m * 1000).round)  if m != 0 || full
	d, m = d.divmod(60) # 秒
	r = sprintf("%02d", m) + r
	if d > 0 || full
		d, m = d.divmod(60) # 分
		r = sprintf("%02d:", m) + r
	end
	if d > 0 || full
		d, m = d.divmod(60) # 時
		r = sprintf("%02d:", m) + r
	end
	return r
end

def pos2sec(pos, fr=nil) # Rational(30000,1001)
	case pos
	when /^(\d+)f$/
		return $1.to_f / fr
	when /^(\d+):(\d+):(\d+(?:\.\d*)?)$/
		return $1.to_i * 3600 + $2.to_i * 60 + $3.to_f
	when /^(\d+):(\d+(?:\.\d*)?)$/
		return $1.to_i * 60 + $2.to_f
	when /^(\d+(?:\.\d*)?s?)$/
		return $1.to_f
	else
		fail "位置の指定が不正です: #{pos}"
	end
end

def vts_num_to_i(vts_num)
	if vts_num =~ /^VTS_(\d+)$/i
		i = $1.to_i
	else
		fail "'VTS_n'の形式で指定してください"
	end
	return i
end

def guess_lang(s)
	case s
	when /(英語|English)/i
		return "eng"
	when /(日本語|Japanese)/i
		return "jpn"
	end

	return nil
end

def get_vobfiles(vts_num)
	if vts_num >= 1
		vobfiles = Dir.glob(sprintf("VTS_%02d_*.VOB", vts_num), File::FNM_CASEFOLD).sort
		vobfiles.shift  if vobfiles.size >= 2 && vobfiles.first =~ /^VTS_\d+_0\.VOB/i
		fail "入力VOBファイルがひとつもありません"  if vobfiles.empty?
		ifofiles = Dir.glob(sprintf("VTS_%02d_*.IFO", vts_num), File::FNM_CASEFOLD).sort
	elsif vts_num == 0
		vobfiles = Dir.glob("VIDEO_TS.VOB", File::FNM_CASEFOLD).sort
		fail "VIDEO_TS.VOBがありません"  if vobfiles.empty?
		ifofiles = Dir.glob("VIDEO_TS.IFO", File::FNM_CASEFOLD).sort
	end
	return [vobfiles, ifofiles]
end

def probe_disc_data_raw
	if !File.exist?("VIDEO_TS.IFO")
		fail "DVDのインデックスファイルが存在しません"
	end

	cmd = [LSDVD_CMD]
	cmd += ["-x"]
	cmd += ["-Or", "."]
	r = Open3.capture3(*cmd)

	if r[0].empty?
		printf("%s\n", r[1])
		fail "lsdvdの実行に失敗しました"
	end

	return eval(r[0])
end

def probe_disc_data
	pd = probe_disc_data_raw

	pd[:track].each.with_index(1) do |title, ix|
		fail "lsdvdのタイトル情報に飛び番があります"  if title[:ix] != ix
		# TODO : アングル情報のチェック
		title[:audio].each.with_index(1) do |audio, ix|
			fail "lsdvdのオーディオ情報に飛び番があります"  if audio[:ix] != ix
		end
		title[:chapter].each.with_index(1) do |chapter, ix|
			fail "lsdvdのチャプター情報に飛び番があります"  if chapter[:ix] != ix
		end
		title[:cell].each.with_index(1) do |cell, ix|
			fail "lsdvdのセル情報に飛び番があります"  if cell[:ix] != ix
		end
		title[:subp].each.with_index(1) do |subp, ix|
			fail "lsdvdの字幕情報に飛び番があります"  if subp[:ix] != ix
		end
	end

	vts_wk = {}
	pd[:track].each do |title|
		vts_wk[title[:vts]] ||= []
		vts_wk[title[:vts]] << title
	end
	vts = []
	vts_wk.each do |v, t|
		vts << {vts:v, titles:t}
	end
	vts.sort_by! { |v| v[:vts] }
	vts.each.with_index(1) do |vts, ix|
		fail "使われているVTS番号に飛び番があります"  if vts[:vts] != ix
	end
	pd[:vts] = vts

	if $adjust_fps
		adjust_fps_factor = Rational(30000,1000) / Rational(30000,1001)
		pd[:track].each do |title|
			title[:length] *= adjust_fps_factor
			title[:chapter].each do |chapter|
				chapter[:length] *= adjust_fps_factor
			end
			title[:cell].each do |cell|
				cell[:length] *= adjust_fps_factor
			end
		end
	end

	return pd
end

def probe_vts_data_raw(vts_num)
	vobfiles, ifofiles = get_vobfiles(vts_num)

	cmd1 = ["cat"]
	cmd1 += vobfiles

	cmd2 = [FFPROBE_CMD]
	cmd2 += ["-hide_banner"]
	cmd2 += ["-loglevel", "warning"]
	cmd2 += ["-analyzeduration", FF_ANALYZEDURATION]
	cmd2 += ["-probesize", FF_PROBESIZE]
	cmd2 += ["-print_format", "json"]
	cmd2 += ["-show_format"]
	cmd2 += ["-show_streams"]
	cmd2 += ["-i", "-"]
	return JSON.parse(Open3.pipeline_r(cmd1, cmd2)[0].read, symbolize_names:true)
end

def probe_vts_data(vts_num)
	disc = probe_disc_data
	if vts_num >= 1
		if !disc[:vts][vts_num - 1]
			fail sprintf("VTS_%02dの情報はありません", vts_num)
		end
		titles = disc[:vts][vts_num - 1][:titles]
	else
		titles = []
	end

	cells = []
	ctmap = {0 => 0.0}
	titles.each do |title|
		title[:cell].each do |cell|
			if !cells.find { |c|
				c[:first_sector] == cell[:first_sector] &&
				c[:last_sector] == cell[:last_sector]
			}
				cells << {
					ix: nil,
					start: nil,
					end: nil,
					length: cell[:length],
					first_sector: cell[:first_sector],
					last_sector: cell[:last_sector],
				}
			end
		end
	end
	cells.sort_by! { |c| c[:first_sector] }
	cells.each.with_index(1) do |cell, ix|
		startsec = ctmap[cell[:first_sector]]
		fail "セル情報が不連続のため、開始時刻を確定できません"  if !startsec
		endsec = startsec + cell[:length]

		cell[:ix] = ix
		cell[:start] = startsec
		ctmap[cell[:last_sector] + 1] = endsec
		cell[:end] = endsec
	end

	chapters = []
	titles.each do |title|
		title[:chapter].each do |chapter|
			cell = title[:cell][chapter[:startcell]-1]
			if !chapters.find { |c|
				c[:length] == chapter[:length] &&
				c[:first_sector] == cell[:first_sector]
			}
				chapters << {
					ix: nil,
					title: title[:ix],
					title_ix: chapter[:ix],
					start: nil,
					end: nil,
					length: chapter[:length],
					first_sector: cell[:first_sector],
				}
			end
		end
	end
	chapters.sort_by! { |c| c[:first_sector] }
	chapters.each.with_index(1) do |chapter, ix|
		startsec = ctmap[chapter[:first_sector]]
		fail "チャプター開始時刻を確定できません"  if !startsec
		endsec = startsec + chapter[:length]

		chapter[:ix] = ix
		chapter[:start] = startsec
		chapter[:end] = endsec
	end

	vobfiles, ifofiles = get_vobfiles(vts_num)

	cmd1 = ["cat"]
	cmd1 += vobfiles

	cmd2 = [FFPROBE_CMD]
	cmd2 += ["-hide_banner"]
	cmd2 += ["-loglevel", "error"]
	cmd2 += ["-analyzeduration", FF_ANALYZEDURATION]
	cmd2 += ["-probesize", FF_PROBESIZE]
	cmd2 += ["-print_format", "json"]
	cmd2 += ["-show_format"]
	cmd2 += ["-show_streams"]
	cmd2 += ["-i", "-"]
	ffprobe = JSON.parse(Open3.pipeline_r(cmd1, cmd2)[0].read, symbolize_names:true)

	streams = ffprobe[:streams]
	streams_v = []
	streams_a = []
	streams_s = []
	ffid = 0
	streams.each.with_index(1) do |stream, ix|
		stream[:ix] = ix
		fail "ffprobeでのストリーム番号に飛び番があります"  if stream[:index] != ix-1

		case stream[:codec_type]
		when "video"
			streams_v << stream
			stream[:ffid] = "0:#{ffid}"
			ffid += 1
		when "audio"
			streams_a << stream
			stream[:ffid] = "0:#{ffid}"
			ffid += 1

			streamid = stream[:id].to_i(0)
			lsdvd = nil
			titles.each do |title|
				title[:audio].each do |audio|
					if audio[:streamid].to_i(0) == streamid
						lsdvd = audio
						break
					end
				end
				break  if lsdvd
			end
			if lsdvd
				stream[:langcode] = lsdvd[:langcode]
				stream[:language] = lsdvd[:language]
				stream[:content] = lsdvd[:content]
				stream[:lang] = LANGTABLE[stream[:langcode]]
				fail sprintf("言語コードが変換できません: %s", stream[:langcode])  if !LANGTABLE.include?(stream[:langcode])
			end
		when "subtitle"
			streams_s << stream
			stream[:ffid] = "0:#{ffid}"
			ffid += 1

			streamid = stream[:id].to_i(0)
			lsdvd = nil
			titles.each do |title|
				title[:subp].each do |subp|
					if subp[:streamid].to_i(0) == streamid
						lsdvd = subp
						break
					end
				end
				break  if lsdvd
			end
			if lsdvd
				stream[:langcode] = lsdvd[:langcode]
				stream[:language] = lsdvd[:language]
				stream[:content] = lsdvd[:content]
				stream[:lang] = LANGTABLE[stream[:langcode]]
				fail sprintf("言語コードが変換できません: %s", stream[:langcode])  if !LANGTABLE.include?(stream[:langcode])
			end
		when "data"
			# NOP
		else
			fail "不明なcodec_typeです: #{stream[:codec_type]}"
		end
	end

	return {
		disc: disc,
		vts_num: vts_num,
		titles: titles,
		chapters: chapters,
		vobfiles: vobfiles,
		ifofiles: ifofiles,
		format: ffprobe[:format],
		streams: streams,
		streams_v: streams_v,
		streams_a: streams_a,
		streams_s: streams_s,
	}
end

def measure_vob_duration(vts_num)
	vobfiles, ifofiles = get_vobfiles(vts_num)

	vobtimes = []
	vobfiles.each do |vobfile|
		cmd = [FFPROBE_CMD]
		cmd += ["-hide_banner"]
		cmd += ["-loglevel", "warning"]
		cmd += ["-print_format", "json"]
		cmd += ["-show_format"]
		cmd += ["-i", vobfile]
		r = Open3.capture3(*cmd)
		ffprobe = JSON.parse(r[0], symbolize_names:true)
		vobtimes << {
			filename: vobfile,
			start: ffprobe[:format][:start_time].to_f,
			duration: ffprobe[:format][:duration].to_f,
			end: ffprobe[:format][:start_time].to_f + ffprobe[:format][:duration].to_f,
		}
	end

	return vobtimes.sum { |v| v[:duration] }
end

def measure_strict_duration(vts_num)
	printf("Measuring strict VTS duration...\n")

	vobfiles, ifofiles = get_vobfiles(vts_num)
	wfile = Tempfile.new(["vtsmeasure", ".wav"])

	cmd1 = ["cat"]
	cmd1 += vobfiles

	cmd2 = [FFMPEG_CMD]
	cmd2 += ["-hide_banner"]
	cmd2 += ["-loglevel", "error"]
	cmd2 += ["-y"]
	cmd2 += ["-i", "-"]
	cmd2 += ["-f", "wav"]
	cmd2 += ["-ac", "1"] # モノラル
	cmd2 += ["-codec:a", "pcm_u8"]
	cmd2 += [wfile.path]
	Open3.pipeline(cmd1, cmd2)

	cmd3 = [FFPROBE_CMD]
	cmd3 += ["-hide_banner"]
	cmd3 += ["-loglevel", "warning"]
	cmd3 += ["-print_format", "json"]
	cmd3 += ["-show_format"]
	cmd3 += ["-i", wfile.path]
	ffprobe = JSON.parse(Open3.capture3(*cmd3)[0], symbolize_names:true)

	return ffprobe[:format][:duration].to_f
end

def probe_disc
	pd = probe_disc_data

	printf("disc title : %s\n", pd[:title])  if pd[:title] != "unknown"
	printf("vmg_id : %s\n", pd[:vmg_id])  if pd[:vmg_id] != "DVDVIDEO-VMG"
	printf("provider id : %s\n", pd[:provider_id])  if pd[:provider_id] != ""

	pd[:vts].each do |vts|
		printf("VTS_%02d :", vts[:vts])
		vts[:titles].each_with_index do |title, i|
			if i == 0
				printf(" %dx%d(%s) %0.2ffps", title[:width], title[:height], title[:aspect], title[:fps])
			else
				print("                               ")
			end
			printf(" Title %d %s(%0.1fs)", title[:ix], sec2hhmmss(title[:length], full:true), title[:length])
			aux = ""
			aux += sprintf(" angle:%d", title[:angles])  if title[:angles] != 1
			aux += sprintf(" audio:%d", title[:audio].size)  if title[:audio].size != 1
			aux += sprintf(" subt:%d", title[:subp].size)  if title[:subp].size != 0
			aux += sprintf(" chpt:%d", title[:chapter].size)  if title[:chapter].size != 1
			aux += sprintf(" longest")  if title[:ix] == pd[:longest_track]
			print(" /" + aux)  if !aux.empty?
			print("\n")
		end
	end
end

def probe_vts(vts_num)
	pd = probe_vts_data(vts_num)

	if $strict_length
		video_duration = measure_strict_duration(vts_num)
	else
		video_duration = measure_vob_duration(vts_num)
	end

	printf("VTS_%02d :", vts_num)

	if pd[:streams_v].size != 1
		fail "想定外のビデオストリーム数: #{pd[:streams_v].size}"
	end

	video = pd[:streams_v].first
	printf(" %dx%d(%s)", video[:width], video[:height], video[:display_aspect_ratio])
	printf(" %0.2ffps", Rational(video[:avg_frame_rate]).to_f)
	printf(" %s", video[:field_order])
	printf(" %s(%0.3fs)", sec2hhmmss(video_duration, full:true), video_duration)

	aux = ""
	#aux += sprintf(" angle:%d", pd[:angles])  if track[:angles] != 1
	aux += sprintf(" audio:%d", pd[:streams_a].size)  if pd[:streams_a].size != 1
	aux += sprintf(" subt:%d", pd[:streams_s].size)  if pd[:streams_s].size != 0
	aux += sprintf(" chpt:%d", pd[:chapters].size)  if pd[:chapters].size != 1
	print(" /" + aux)  if !aux.empty?
	print("\n")

	pd[:disc][:track].each do |title|
		next  if title[:vts] != vts_num
		if title[:angles] != 1
			printf("Angle %d :", 1)
			print(" 複数アングルがあります\n")
		end
	end

	pd[:streams_a].each.with_index(1) do |audio, ix|
		printf("Audio %d :", ix)
		printf(" %s %s %dHz %dch", audio[:language], audio[:codec_long_name], audio[:sample_rate], audio[:channels])
		printf(" %s", audio[:content])  if audio[:content] && !audio[:content].empty? && audio[:content] != "Undefined"
		print("\n")
	end

	pd[:streams_s].each.with_index(1) do |subp, ix|
		printf("Subtitle %d :", ix)
		printf(" %s", subp[:language])
		printf(" %s", subp[:content])  if subp[:content] && !subp[:content].empty? && subp[:content] != "Undefined"
		print("\n")
	end

	pd[:chapters].each.with_index(1) do |chapter, ix|
		printf("Chapter %d :", ix)
		printf(" %s - %s %s(%0.3fs)", sec2hhmmss(chapter[:start], full:true), sec2hhmmss(chapter[:end], full:true),
		 							sec2hhmmss(chapter[:length]), chapter[:length])
		print("\n")
	end

	pd[:disc][:track].each do |title|
		next  if title[:vts] != vts_num

		if title[:angles] > pd[:streams_v].size
			printf("タイトル%dのアングルは%d個ですが、ビデオストリームは%d個しかありません\n",
				title[:ix], title[:angles], pd[:streams_v].size)
		end
		if title[:audio].size > pd[:streams_a].size
			printf("タイトル%dのオーディオチャネルは%d個ですが、オーディオストリームは%d個しかありません\n",
				title[:ix], title[:audio].size, pd[:streams_a].size)
		end
		if title[:subp].size > pd[:streams_s].size
			printf("タイトル%dの字幕数は%d個ですが、字幕ストリームは%d個しかありません\n",
				title[:ix], title[:subp].size, pd[:streams_s].size)
		end
	end
end

def dvd2mp4(vts_num)
	pd = probe_vts_data(vts_num)

	# ファイルのメタ情報を決定
	if !$metadata[:album_name]
		if pd[:disc][:title] && pd[:disc][:title] != "unknown"
			$stdout.printf("アルバム名が指定されていません: ディスク情報から得た %s とします\n", pd[:disc][:title])
			$metadata[:album_name] = pd[:disc][:title]
		# else
		# 	$stdout.printf("アルバム名が指定されていません\n")
		end
	end

	if !$metadata[:title_name]
		$stdout.printf("タイトルが指定されていません\n")
	end

	# if !$metadata[:title_num]
	# 	$stdout.printf("タイトル番号が指定されていません\n")
	# end

	# 出力ファイル名を生成
	if $metadata[:title_name]
		if $metadata[:title_num]
			dst_basename = "#{$metadata[:title_num]} #{$metadata[:title_name]}".strip
		else
			dst_basename = "#{$metadata[:title_name]}"
		end
	else
		dst_basename = sprintf("VTS_%02d", vts_num)
	end
	if $testmode
		dst_basename = "(test)" + dst_basename
	end

	# 開始:終了位置を決定
	framerate = Rational(pd[:streams_v].first[:avg_frame_rate])
	start_sec = $start_pos ? pos2sec($start_pos, framerate) : nil
	end_sec = $end_pos ? pos2sec($end_pos, framerate) : nil
	duration_sec = $duration ? pos2sec($duration, framerate) : nil

	if start_sec || end_sec || duration_sec
		start_sec = 0  if !start_sec
		if end_sec
			duration_sec = end_sec - start_sec
		elsif duration_sec
			end_sec = start_sec + duration_sec
		end
	end

	# ストリームのタイトル等を決定
	deinterlace = false
	pd[:streams_v].each_with_index do |stream, ix|
		if stream[:field_order] && stream[:field_order] != "progressive"
			deinterlace = true
		end
		title = $metadata[:s_video_name][ix]
		# if !title
		# 	$stdout.printf("ビデオストリーム #{ix+1} のタイトルが指定されていません\n")
		# 	title = "#{stream[:codec_long_name]} #{stream[:width]}x#{stream[:height]} #{stream[:display_aspect_ratio]}".strip
		# end
		stream[:title] = title
	end

	pd[:streams_a].each_with_index do |stream, ix|
		title = $metadata[:s_audio_name][ix]
		if !title
			$stdout.printf("オーディオストリーム #{ix+1} のタイトルが指定されていません\n")
			if stream[:lang]
				title = "#{stream[:language]} #{stream[:channel_layout]}".strip
			else
				title = "#{stream[:channel_layout]}".strip
			end
		else
			if !stream[:lang]
				stream[:lang] = guess_lang(title)
			end
		end
		stream[:title] = title
	end

	pd[:streams_s].each_with_index do |stream, ix|
		title = $metadata[:s_subtitle_name][ix]
		if !title
			$stdout.printf("字幕ストリーム #{ix+1} のタイトルが指定されていません\n")
			title = "#{stream[:language]}"
		else
			if !stream[:lang]
				stream[:lang] = guess_lang(title)
			end
		end
		stream[:title] = title
	end

	# 出力するストリームの数を種類ごとに数える
	streams_v_output = pd[:streams_v].count { |s| s[:title] != "omit" }
	streams_a_output = pd[:streams_a].count { |s| s[:title] != "omit" }
	streams_s_output = pd[:streams_s].count { |s| s[:title] != "omit" }

	# 指定長より短いチャプターは削除
	pd[:chapters].delete_if { |c| c[:length] < $delete_chpt_sec }

	# チャプター名
	pd[:chapters].each_with_index do |chapter, ix|
		title = $metadata[:chapter_name][ix]
		if !title
			$stdout.printf("チャプター #{ix+1} のタイトルが指定されていません\n")
			title = "Chapter #{ix+1}"
		end
		chapter[:title] = title
	end

	# 出力対象のチャプター数を数える
	chapters_output = 0
	pd[:chapters].each.with_index(1) do |chapter, ix|
		next  if chapter[:title] == "omit"
		next  if start_sec && chapter[:end] <= (start_sec + 0.5)
		next  if end_sec && chapter[:start] >= (end_sec - 0.5)

		chapters_output += 1
	end

	# チャプター情報ファイルを作成
	cfile = Tempfile.new(["chapter", ".txt"])
	cfile.printf(";FFMETADATA1\n")
	if !$split_chapter && chapters_output >= 2
		pd[:chapters].each.with_index(1) do |chapter, ix|
			next  if chapter[:title] == "omit"
			next  if start_sec && chapter[:end] <= (start_sec + 0.5)
			next  if end_sec && chapter[:start] >= (end_sec - 0.5)

			cfile.printf("[CHAPTER]\n")
			cfile.printf("TIMEBASE=1/1000000\n")
			cfile.printf("START=%d\n", chapter[:start] * 1000000)
			cfile.printf("END=%d\n", chapter[:end] * 1000000)
			cfile.printf("title=%s\n", chapter[:title])
		end
	end
	cfile.flush
	system("cat", cfile.path)  if $dryrun

	# 対象VOB,IFOの決定
	vobfiles = pd[:vobfiles]
	if $dryrun
		vobfile = vobfiles.first
	else
		vfile = Tempfile.new(["dvd2mp4", ".vob"])
		vobfile = vfile.path
		cmdv1 = ["cat"]
		cmdv1 += vobfiles

		cmdv2 = [FFMPEG_CMD]
		cmdv2 += ["-hide_banner"]
		cmdv2 += ["-loglevel", "error"]
		cmdv2 += ["-analyzeduration", FF_ANALYZEDURATION]
		cmdv2 += ["-probesize", FF_PROBESIZE]
		cmdv2 += ["-y"]
		cmdv2 += ["-i", "-"]
		cmdv2 += ["-codec", "copy"]
		cmdv2 += ["-map", "0", "-map", "-0:d"]
		cmdv2 += ["-f", "vob"]
		cmdv2 += [vfile.path]

		printf("Writing work VOB...\n")
		Open3.pipeline(cmdv1, cmdv2)
		# fail "#{$?}"  if $? != 0
		printf("...Complete.\n")
	end

	ifofiles = pd[:ifofiles]
	ifofile = ifofiles.first

	# 変換本体

	cmd2 = [FFMPEG_CMD]
	cmd2 += ["-hide_banner"]
	cmd2 += ["-loglevel", "info"]
	cmd2 += ["-analyzeduration", FF_ANALYZEDURATION]
	cmd2 += ["-probesize", FF_PROBESIZE]
	cmd2 += ["-y"]  if $overwrite || $testmode
	cmd2 += ["-ifo_palette", ifofile]  if ifofile
	cmd2 += ["-i", "-"]
	cmd2 += ["-i", vobfile]
	cmd2 += ["-i", cfile.path]
	cmd2 += ["-map_chapters", "1"]

	# cmd2 += ["-max_muxing_queue_size", "2048"]
	cmd2 += ["-f", "mp4"]
	cmd2 += ["-movflags", "+faststart+disable_chpl"]
	cmd2 += ["<<startpoiont>>"]
	cmd2 += ["<<duration>>"]

	if streams_v_output >= 1
		cmd2 += ["-preset:v", $testmode ? "ultrafast" : "veryslow"]
		cmd2 += ["-pix_fmt", "yuv420p"]
		cmd2 += ["-crf:v", $crf.to_s]
		if $quality_a == "l"
			cmd2 += ["-maxrate:v", "1.0M"]
			cmd2 += ["-bufsize:v", "2.5M"]
		end
		cmd2 += ["-tune:v", $video_tune]  if $video_tune
		video_aspect = $video_aspect || pd[:streams_v].first[:display_aspect_ratio]
		if $video_rotate == 90 || $video_rotate == 270
			video_aspect = "#{$2}:#{$1}"  if video_aspect =~ /(\d+):(\d)+/
		end
		cmd2 += ["-aspect:v", video_aspect]

		filters_v = []

		filters_v << ($testmode ? "bwdif=mode=send_frame" : "bwdif=mode=send_field")  if deinterlace

		case $video_tune
		when "animation"
			filters_v << "hqdn3d"
		end

		if $whitepoint || $blackpoint
			w = $whitepoint ? [$whitepoint[0] || 1, $whitepoint[1] || 1, $whitepoint[2] || 1] : [1,1,1]
			b = $blackpoint ? [$blackpoint[0] || 0, $blackpoint[1] || 0, $blackpoint[2] || 0] : [0,0,0]
			filters_v << "colorlevels=rimin=#{b[0]}:gimin=#{b[1]}:bimin=#{b[2]}:rimax=#{w[0]}:gimax=#{w[1]}:bimax=#{w[2]}"
		end

		if $video_gamma || $video_saturation
			eq = []
			eq << "gamma=#{$video_gamma}"  if $video_gamma
			eq << "saturation=#{$video_saturation}"  if $video_saturation
			filters_v << "eq=#{eq.join(":")}"
		end

		if $video_crop
			crop_w = pd[:streams_v].first[:width] - $video_crop[2] - $video_crop[3]
			crop_h = pd[:streams_v].first[:height] - $video_crop[0] - $video_crop[1]
			crop_x = $video_crop[2]
			crop_y = $video_crop[0]
			filters_v << "crop=w=#{crop_w}:h=#{crop_h}:x=#{crop_x}:y=#{crop_y}"
			filters_v << "scale=#{pd[:streams_v].first[:width]}:#{pd[:streams_v].first[:height]}"
		end

		case $video_rotate
		when 90
			filters_v << "transpose=clock"
		when 180
			filters_v << "hflip" << "vflip"
		when 270
			filters_v << "transpose=cclock"
		end

		cmd2 += ["-filter:v", filters_v.join(",")]  if filters_v.size > 0
	end

	if streams_a_output >= 1
		if $flac_audio
			cmd2 += ["-codec:a", "flac", "-strict", "experimental"]
		else
			cmd2 += ["-codec:a", "libfdk_aac"]
			cmd2 += ["-profile:a", "aac_low"]

			case $quality_a
			when "h"
				cmd2 += ["-vbr:a", "5"]
			when "l"
				cmd2 += ["-vbr:a", "1"]
				cmd2 += ["-cutoff:a", "14000"]
			else
				cmd2 += ["-vbr:a", "3"]
				cmd2 += ["-cutoff:a", "18000"]
			end
		end
	end

	if streams_s_output >= 1
		cmd2 += ["-codec:s", "dvd_subtitle"]
	end

	cmd2 += ["-metadata", "album=#{$metadata[:album_name]}"]  if $metadata[:album_name]
	cmd2 += ["-metadata", "track=#{$metadata[:title_num]}"]  if $metadata[:title_num]
	cmd2 += ["-metadata", "title=#{$metadata[:title_name]}"]  if $metadata[:title_name]
	cmd2 += ["-metadata", "encoding_tool=#{$commandline}"]

	# 出力するストリームとストリーム毎のオプションを指定

	scount = 0

	pd[:streams_v].each do |stream|
		next  if stream[:title] == "omit"

		cmd2 += ["-map", stream[:ffid]]

		if streams_v_output >= 2
			cmd2 += ["-metadata:s:#{scount}", "language=#{stream[:lang]}"]
			cmd2 += ["-metadata:s:#{scount}", "title=#{stream[:title]}"]
			cmd2 += ["-metadata:s:#{scount}", "handler_name=#{stream[:title]}"]
		end

		scount += 1
	end

	pd[:streams_a].each do |stream|
		next  if stream[:title] == "omit"

		cmd2 += ["-map", stream[:ffid]]

		# if streams_a_output >= 2
			cmd2 += ["-metadata:s:#{scount}", "language=#{stream[:lang]}"]
			cmd2 += ["-metadata:s:#{scount}", "title=#{stream[:title]}"]
			cmd2 += ["-metadata:s:#{scount}", "handler_name=#{stream[:title]}"]
		# end

		scount += 1
	end

	pd[:streams_s].each do |stream|
		next  if stream[:title] == "omit"

		cmd2 += ["-map", stream[:ffid]]

		# if streams_s_output >= 2
			cmd2 += ["-metadata:s:#{scount}", "language=#{stream[:lang]}"]
			cmd2 += ["-metadata:s:#{scount}", "title=#{stream[:title]}"]
			cmd2 += ["-metadata:s:#{scount}", "handler_name=#{stream[:title]}"]
		# end

		scount += 1
	end

# TODO:サムネイル画像

	if $split_chapter
		if chapters_output < 1
			fail "出力対象のチャプターがひとつもありません"
		end

		pd[:chapters].each.with_index(1) do |chapter, ix|
			next  if chapter[:title] == "omit"

			cmd2c = cmd2.dup

			s = chapter[:start]
			s += start_sec  if start_sec
			cmd2c[cmd2c.index("<<startpoiont>>"), 1] = ["-ss", "#{s}"]
			s = chapter[:length]
			s -= start_sec  if start_sec
			s = [s, duration_sec].min  if duration_sec
			cmd2c[cmd2c.index("<<duration>>"), 1] = ["-t", "#{s}"]

			title = chapter[:title]
			if title
				if $metadata[:title_name]
					cmd2c += ["-metadata", "title=#{$metadata[:title_name]} #{title}".rstrip]
				else
					cmd2c += ["-metadata", "title=#{title}"]
				end
			else
				title = "#{ix}"
			end
			dst_filename = dst_basename + " " + title + ".mp4"
			cmd2c += [dst_filename]

			if $dryrun
				p cmd2c
			else
				system(*cmd2c)
				fail "#{$?}"  if $? != 0

				if File.exist?(dst_filename)
					timestamp_src = (ifofiles + vobfiles).first
					atime = File.atime(timestamp_src)
					mtime = File.mtime(timestamp_src)
					File.utime(atime, mtime, dst_filename)
				end
			end
		end
	else
		cmd2[cmd2.index("<<startpoiont>>"), 1] = start_sec ? ["-ss", start_sec.round(3).to_s] : []
		cmd2[cmd2.index("<<duration>>"), 1] = duration_sec ? ["-t", duration_sec.round(3).to_s] : []
		dst_filename = dst_basename + ".mp4"
		cmd2 += [dst_filename]

		if $dryrun
			p cmd2
		else
			system(*cmd2)
			fail "#{$?}"  if $? != 0

			if File.exist?(dst_filename)
				timestamp_src = (ifofiles + vobfiles).first
				atime = File.atime(timestamp_src)
				mtime = File.mtime(timestamp_src)
				File.utime(atime, mtime, dst_filename)
			end
		end
	end
end

def show_encoding_tool(filename)
	cmd = [FFPROBE_CMD]
	cmd += ["-hide_banner"]
	cmd += ["-loglevel", "warning"]
	cmd += ["-print_format", "json"]
	cmd += ["-show_format"]
	cmd += ["-i", filename]
	format = JSON.parse(Open3.capture3(*cmd)[0], symbolize_names:true)

	printf("%s\n", format[:format][:tags][:encoder])
end

def main(args)
	var_init
	$commandline = ProgName + " " + myShellwordsJoin(args)

	args.options do |opt|
		opt.banner = "#{ProgName} v#{Version} #{Copyright}\n" +
						"Usage: #{ProgName} [options] VTS_nn..."

		$probe = false
		opt.on("-p", "--[no-]probe",
			"ファイルの情報を表示する") do |v|
			$probe = v
		end

		$probe_raw = false
		opt.on("-r", "--[no-]probe-raw",
			"ファイルの情報を表示する(非編集)") do |v|
			$probe_raw = v
		end

		$start_pos = nil
		opt.on("-s", "--startpoint=pos", String,
			"開始位置を指定する(秒/時分秒/フレーム)") do |v|
			$start_pos = v
		end

		$end_pos = nil
		opt.on("-e", "--endpoint=pos", String,
			"終了位置を指定する") do |v|
			$end_pos = v
			$duration = nil
		end

		$duration = nil
		opt.on("-d", "--duration=dur", String,
			"出力する長さを指定する") do |v|
			$duration = v
			$end_pos = nil
		end

		$split_chapter = false
		opt.on("--[no-]split-chapter",
			"チャプターごとに分割して出力する") do |v|
			$split_chapter = v
		end

		$metadata[:album_name] = nil
		opt.on("--album-name=str", String,
			"アルバム名を指定") do |v|
			$metadata[:album_name] = v
		end

		$metadata[:title_num] = nil
		opt.on("--title-num=n", String,
			"タイトル番号を指定") do |v|
			$metadata[:title_num] = v
		end

		$metadata[:title_name] = nil
		opt.on("-t", "--title=str", String,
			"タイトルを指定") do |v|
			$metadata[:title_name] = v
		end

		$metadata[:s_video_name] = []
		opt.on("--title:v=str", String,
			"ビデオストリームのタイトルを指定('omit'で出力しない/'auto'で自動)") do |v|
			v = nil  if v == "auto"
			$metadata[:s_video_name] << v
		end

		$metadata[:s_audio_name] = []
		opt.on("--title:a=str", String,
			"オーディオストリームのタイトルを指定") do |v|
			v = nil  if v == "auto"
			$metadata[:s_audio_name] << v
		end

		$metadata[:s_subtitle_name] = []
		opt.on("--title:s=str", String,
			"字幕ストリームのタイトルを指定") do |v|
			v = nil  if v == "auto"
			$metadata[:s_subtitle_name] << v
		end

		$metadata[:chapter_name] = []
		opt.on("--title:c=str", String,
			"チャプタータイトルを指定") do |v|
			v = nil  if v == "auto"
			$metadata[:chapter_name] << v
		end

		$delete_chpt_sec = 0
		opt.on("--delete-short-chapter=n", Float,
			"n秒より短いチャプターを削除する") do |v|
			$delete_chpt_sec = v
		end

		$video_tune = nil
		opt.on("--tune:v=str", String,
			"ビデオの種類(film|animation|grain|stillimage...)") do |v|
			$video_tune = v
		end

		$quality_v = nil
		$quality_a = nil
		opt.on("--hq",
			"高画質,高音質でエンコードする") do
			$quality_v = "h"
			$quality_a = "h"
		end
		opt.on("--hq:v",
			"高画質でエンコードする") do
			$quality_v = "h"
		end
		opt.on("--hq:a",
			"高音質でエンコードする") do
			$quality_a = "h"
		end
		opt.on("--lq",
			"低画質,低音質でエンコードする") do
			$quality_v = "l"
			$quality_a = "l"
		end
		opt.on("--lq:v",
			"低画質でエンコードする") do
			$quality_v = "l"
		end
		opt.on("--lq:a",
			"低音質でエンコードする") do
			$quality_a = "l"
		end

		$crf = nil
		opt.on("--crf=n", Float,
			"VBR画質を指定する(0:ロスレス - 21.0:デフォルト - 51:低)") do |v|
			$crf = v
		end

		$video_crop = nil
		opt.on("--crop-video=t,b,l,r", Array,
			"映像を切り取り(上,下,左,右)") do |v|
			$video_crop = v.map { |v| v.to_i }
		end

		$video_aspect = nil
		opt.on("--aspect-video=r", String,
			"映像のアスペクト比(w:h)") do |v|
			$video_aspect = v
		end

		$video_rotate = nil
		opt.on("--rotate-video=n", String, ["90", "180", "270"],
			"映像を回転(90|180|270)") do |v|
			$video_rotate = v.to_i
		end

		$whitepoint = nil
		opt.on("--white-point=r,g,b", Array,
			"映像のホワイトポイント(0～255)") do |v|
			$whitepoint = v.map { |v| v.to_i / 255.0 }
		end

		$blackpoint = nil
		opt.on("--black-point=r,g,b", Array,
			"映像のブラックポイント(0～255)") do |v|
			$blackpoint = v.map { |v| v.to_i / 255.0 }
		end

		$video_gamma = nil
		opt.on("--gamma=n", Float,
			"映像のガンマ補正(0.1〜1(デフォルト)〜10)") do |v|
			$video_gamma = v
		end

		$video_saturation = nil
		opt.on("--saturation=n", Float,
			"映像の彩度補正(0〜1(デフォルト)〜3.0)") do |v|
			$video_saturation = v
		end

		$flac_audio = false
		opt.on("-y", "--[no-]flacaudio",
			"音声をFLACでエンコードする") do |v|
			$flac_audio = v
		end

		$adjust_fps = true
		opt.on("--[no-]adjust-fps",
			"チャプター時間のfpsの調整を行う") do |v|
			$adjust_fps = v
		end

		$strict_length = false
		opt.on("--[no-]strict-length",
			"再生時間を厳密に測定する") do |v|
			$strict_length = v
		end

		$overwrite = false
		opt.on("-y", "--[no-]overwrite",
			"出力ファイルが既に存在しても上書きする") do |v|
			$overwrite = v
		end

		$testmode = false
		opt.on("--[no-]testmode",
			"テストモード(高速,低画質)") do |v|
			$testmode = v
		end

		$dryrun = false
		opt.on("--[no-]dry-run",
			"変換処理を実際には行わない") do |v|
			$dryrun = v
		end

		$show_encoder = false
		opt.on("--[no-]show-encoder",
			"エンコーダ情報を表示") do |v|
			$show_encoder = v
		end

		opt.parse!

		if $flac_audio
			$quality_a = nil
		end

		if !$crf
			case $quality_v
			when "h"
				$crf = 19.0
			when "l"
				$crf = 24.0
			else
				$crf = 21.0
			end
		end

		if $testmode
			$crf = 36.0
			$flac_audio = false
			$quality_v = "l"
			$quality_a = "l"
		end

		if args.empty?
			if $probe_raw
				pp probe_disc_data_raw
			elsif $probe
				probe_disc
			else
				print(opt.help)
			end
		else
			args.each do |arg|
				if $show_encoder
					show_encoding_tool(arg)
				else
					vts_num = vts_num_to_i(arg)
					if $probe_raw
						pp probe_vts_data_raw(vts_num)
					elsif $probe
						probe_vts(vts_num)
					else
						dvd2mp4(vts_num)
					end
				end
			end
		end
	end

	return $rcode
end

exit main(ARGV)
